<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Import the p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  
  <title>Particle System</title>
  <style>
    /* A simple reset to make the canvas fill the screen */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden; /* Prevents scrollbars */
      background: #202020; /* Dark grey background */
    }
    
    main {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
      position: relative; /* New: for positioning video */
    }
    
    #p5-canvas-container {
      width: 100%;
      height: 100%;
      position: relative; /* New: to ensure it has a stacking context */
      z-index: 3; /* MODIFIED: Was 2, now 3 (on top of buttons) */
    }
    
    /* NEW: Video Player Styling */
    #animation-video {
      display: none; /* Hide by default */
      position: absolute; /* Position relative to main */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1; /* Video behind canvas */
      object-fit: cover;
      /* Width and height will be set by JS */
    }
    
    /* NEW: Portal Video Styling */
    #portal-video {
      display: none; /* Hide by default */
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 1; /* Behind canvas, same level as animation-video */
    }
    
    /* --- NEW: Portal Button Image Sequence Styling --- */
    #portal-button-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2; /* MODIFIED: Was 3, now 2 (behind p5 canvas) */
      pointer-events: none; /* Container doesn't block p5 */
    }
    
    .portal-button {
      position: absolute;
      pointer-events: auto; /* Buttons ARE interactive */
      cursor: pointer;
      background-repeat: no-repeat;
      background-color: transparent;
      /* background-size and background-position handled by JS */
    }

    /* --- SPRITE SHEET SOURCES --- */
    #purple-button-seq {
      background-image: url('https://raw.githubusercontent.com/colinwillow/sprites/main/purple_button_sprites.jpg');
    }
    
    #green-button-seq {
      background-image: url('https://raw.githubusercontent.com/colinwillow/sprites/main/green_button_sprites.jpg');
    }

    #blue-button-seq {
      background-image: url('https://raw.githubusercontent.com/colinwillow/sprites/main/blue_button_sprites.jpg');
    }
    
    #red-button-seq {
      background-image: url('https://raw.githubusercontent.com/colinwillow/sprites/main/red_button_sprites.jpg');
    }
    /* --- END SPRITE SHEET SOURCES --- */

    /* NEW: SVG Logo Styling */
    #logo-svg {
      position: absolute;
      top: 40px; /* MODIFIED: Set to center of 80px bar */
      left: 40px;
      width: 150px; /* Or any size you prefer */
      z-index: 10; /* Make sure it's on top of the canvas */
      
      /* This filter trick forces the black SVG to white */
      filter: brightness(0) invert(1);
      
      /* NEW: Add transition for smooth color change */
      transition: filter 0.5s ease;
      
      /* NEW: Add transform for vertical centering */
      transform: translateY(-50%);
    }
    
    /* NEW: Light theme logo color */
    body.light-theme #logo-svg {
      filter: brightness(0) invert(0.2); /* Dark grey, approx rgb(51, 51, 51) */
    }
    
    /* NEW: Styles for the theme toggle switch */
    .theme-switch-wrapper {
      position: absolute;
      top: 25px;
      right: 20px;
      display: flex;
      align-items: center;
      z-index: 100; /* Above everything */
    }
    .theme-switch {
      display: inline-block;
      height: 26px; /* Taller */
      position: relative;
      width: 50px; /* Wider */
    }
    .theme-switch input {
      display: none;
    }
    .slider {
      background-color: #555; /* Darker track */
      bottom: 0;
      cursor: pointer;
      left: 0;
      position: absolute;
      right: 0;
      top: 0;
      transition: .4s;
    }
    .slider:before {
      background-color: #fff;
      bottom: 4px; /* Centered */
      content: "";
      height: 18px; /* Smaller circle */
      left: 4px;
      position: absolute;
      transition: .4s;
      width: 18px;
    }
    input:checked + .slider {
      background-color: #ccc; /* Light track */
    }
    input:checked + .slider:before {
      transform: translateX(24px); /* Adjusted translation */
    }
    .slider.round {
      border-radius: 26px;
    }
    .slider.round:before {
      border-radius: 50%;
    }
    /* End of toggle styles */
    
  </style>
</head>

<!-- MODIFIED: Start with default dark theme, class will be toggled -->
<body>
  <!-- MODIFIED: Merged two <main> tags into one -->
  <main>
    <!-- NEW: Theme Toggle HTML -->
    <div class="theme-switch-wrapper">
      <label class="theme-switch" for="theme-toggle-input">
        <input type="checkbox" id="theme-toggle-input">
        <span class="slider round"></span>
      </label>
    </div>
    <!-- END NEW -->
    
    <!-- NEW: SVG Logo -->
    <img id="logo-svg" src="https://raw.githubusercontent.com/colinwillow/SVGs/main/Colin_Willow.svg" alt="Colin Willow Logo">
    
    <!-- NEW: Video Player -->
    <video id="animation-video" loop muted playsinline>
      <!-- Use the raw content link for the video -->
      <source src="https://raw.githubusercontent.com/colinwillow/videos_02/main/Hero_Video_01.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
    
    <!-- MODIFIED: Replaced img with video -->
    <video id="portal-video" loop muted playsinline autoplay>
      <source src="https://raw.githubusercontent.com/colinwillow/videos/main/portal_generator_background_16x9.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
    
    <!-- --- NEW: Portal Button Image Sequence HTML --- -->
    <!-- All buttons are now DIVs for Sprite Sheets -->
    <div id="portal-button-container">
      <div id="purple-button-seq" class="portal-button" title="Purple Portal Button"></div>
      <div id="green-button-seq" class="portal-button" title="Green Portal Button"></div>
      <div id="blue-button-seq" class="portal-button" title="Blue Portal Button"></div>
      <div id="red-button-seq" class="portal-button" title="Red Portal Button"></div>
    </div>
    <!-- --- END NEW --- -->
    
    <!-- p5.js particles will be rendered here -->
    <div id="p5-canvas-container"></div>
  </main>

  <!--
    ===============================================================
    NEW: SVG CONTAINER FOR 'CODE' HOVER
    ===============================================================
  -->
  <div style="display:none">
    <svg id="coding-svg" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 784.3 174.2">
      <defs>
        <style>
          .st0 {
            fill: none;
            stroke: #231f20;
          }
        </style>
      </defs>
      <path class="st0" d="M121,153.4c-11,6.8-24,10.2-37.8,10.2-34.8,0-71.6-26.8-71.6-75.8S48,12.4,81.6,12.4s28.6,3.6,39.4,10.2"/>
      <path class="st0" d="M209.8,12.4c39.2,0,69.8,31.2,69.8,75.6s-30.6,75.6-69.8,75.6-69.6-31.2-69.6-75.6S170.6,12.4,209.8,12.4Z"/>
      <path class="st0" d="M422.4,87.6c0,46.2-32,74.6-77.2,74.6h-26.6V13.8h26.6c45.2,0,77.2,27.6,77.2,73.8Z"/>
      <path class="st0" d="M464,13.8v148.4"/>
      <path class="st0" d="M514.4,162.2V13.8h3.2l98.2,148.4h.2V13.8"/>
      <path class="st0" d="M769.2,84v70.6c-9.4,4.8-26.2,9-40.8,9-39.6,0-70.8-29.8-70.8-75.8s31.2-75.4,69.6-75.4,29.8,3.6,41.8,10.8"/>
    </svg>
  </div>

  <!--
    ===============================================================
    NEW: SVG CONTAINER FOR 'MOTION' HOVER
    ===============================================================
  -->
  <div id="svg-container-motion" style="display: none;">
    <svg id="motion-svg" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 822.1 174.2">
      <defs>
        <style>
          .st0 {
            fill: none;
            stroke: #231f20;
          }
        </style>
      </defs>
      <path class="st0" d="M8.6,162.2L33.4,13.8h2.8l52.8,143.8h.2L140.8,13.8h2.8l25.4,148.4"/>
      <path class="st0" d="M266,12.4c39.2,0,69.8,31.2,69.8,75.6s-30.6,75.6-69.8,75.6-69.6-31.2-69.6-75.6S226.8,12.4,266,12.4Z"/>
      <path class="st0" d="M397.8,13.8v148.4M344.8,13.8h103.4"/>
      <path class="st0" d="M480.6,13.8v148.4"/>
      <path class="st0" d="M589.2,12.4c39.2,0,69.8,31.2,69.8,75.6s-30.6,75.6-69.8,75.6-69.6-31.2-69.6-75.6,30.4-75.6,69.6-75.6Z"/>
      <path class="st0" d="M698,162.2V13.8h3.2l98.2,148.4h.2V13.8"/>
    </svg>
  </div>
  
  <!-- =============================================== -->
  <!-- SCRIPT: p5.js Particle Code -->
  <!-- =============================================== -->
  <script>
    // ... existing code for RectButton class ...
    class RectButton {
      constructor(x, y, w, h, txt, colorOverride) {
        this.x = x; this.y = y; this.w = w; this.h = h; this.txt = txt;
        this.baseColor = color(255, 255, 255, 150);
        this.hoverColor = color(255, 255, 255, 255);
        this.activeColor = colorOverride || color(50, 255, 50, 255);
        this.textColor = color(0, 0, 0, 200);
        this.isHovering = false; this.isActive = false; 
      }
      isHovered() {
        let mouseIsOver = (mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2);
        this.isHovering = mouseIsOver;
        return this.isHovering;
      }
      show() {
        push();
        rectMode(CENTER); textAlign(CENTER, CENTER);
        if (this.isActive) { fill(this.activeColor); noStroke(); } 
        else if (this.isHovering) { fill(this.hoverColor); noStroke(); } 
        else { fill(this.baseColor); noStroke(); }
        rect(this.x, this.y, this.w, this.h, 5);
        fill(this.textColor); textSize(14); text(this.txt, this.x, this.y);
        pop();
      }
    }
    
    // ... existing code for SpaceButton class ...
    class SpaceButton {
      constructor(x, y, w, h, activeColor) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.h1_base = h; this.h2_base = h; this.h1_hover = 5; this.h2_hover = h + 10;
        this.h1_lerp = this.h1_base; this.h2_lerp = this.h2_base;
        this.isActive = false; this.isHovering = false;
        this.baseColor = color(70, 70, 70, 150);
        this.hoverColor = color(255, 255, 255, 255);
        this.activeColor = activeColor; this.currentColor = this.baseColor;
      }
      isHovered() {
        let mouseIsOver = (mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2);
        this.isHovering = mouseIsOver; return this.isHovering;
      }
      hoverAnimate() {
        if (this.isHovering || this.isActive) {
          this.h1_lerp = lerp(this.h1_lerp, this.h1_hover, 0.4);
          this.h2_lerp = lerp(this.h2_lerp, this.h2_hover, 0.4);
        } else {
          this.h1_lerp = lerp(this.h1_lerp, this.h1_base, 0.2);
          this.h2_lerp = lerp(this.h2_lerp, this.h2_base, 0.2);
        }
      }
      show() {
        this.isHovered(); this.hoverAnimate();
        let currentBaseColor = this.baseColor; let currentHoverColor = this.hoverColor; let currentActiveColor = this.activeColor;
        if (isLightTheme) {
          currentHoverColor = color(50, 50, 50, 255); currentActiveColor = color(50, 50, 50, 255);
        }
        if (this.isActive) { this.currentColor = currentActiveColor; } 
        else if (this.isHovering) { this.currentColor = currentHoverColor; } 
        else { this.currentColor = currentBaseColor; }
        push(); translate(this.x, this.y); rectMode(CENTER); noFill(); strokeWeight(1);
        stroke(this.currentColor); rect(0, 0, this.w, this.h1_lerp, 2); rect(0, 0, this.w - 10, this.h2_lerp, 5);
        noStroke(); fill(this.currentColor); textAlign(CENTER, CENTER); textSize(14); text("BACK TO PORTAL", 0, 0);
        pop();
      }
    }
    
    // ... existing code for AnimatedButton class ...
    class AnimatedButton {
      constructor(x, y, r, activeColor) {
        this.x = x; this.y = y; this.r_base = r; this.r1 = r; this.r2 = r;
        this.hoverRadius = 25; this.isActive = false; this.isHovering = false;
        this.baseColor = color(255, 255, 255, 100); this.hoverColor = color(255, 255, 255); this.activeColor = activeColor;
      }
      isHovered() {
        const distance = dist(mouseX, mouseY, this.x, this.y);
        this.isHovering = (distance < this.hoverRadius); return this.isHovering;
      }
      hoverAnimate() {
         if (this.isHovering || this.isActive) {
           this.r1 = lerp(this.r1, 80, 0.4); this.r2 = lerp(this.r2, 5, 0.4);
         } else {
           this.r1 = lerp(this.r1, this.r_base, 0.2); this.r2 = lerp(this.r2, this.r_base, 0.2);
         }
      }
      show() {
        this.isHovered(); this.hoverAnimate();
        push(); translate(this.x, this.y); strokeWeight(2);
        let currentBaseColor = this.baseColor; let currentHoverColor = this.hoverColor;
        if (isLightTheme) {
          currentBaseColor = color(50, 50, 50, 100); currentHoverColor = color(50, 50, 50, 255);
        }
        if (this.isActive) { stroke(this.activeColor); } 
        else if (this.isHovering) { stroke(currentHoverColor); } 
        else { stroke(currentBaseColor); }
        noFill();
        push(); arc(0, 0, this.r2, this.r2, 0, TWO_PI/6); arc(0, 0, this.r2, this.r2, 2*TWO_PI/6, 3*TWO_PI/6); arc(0, 0, this.r2, this.r2, 4*TWO_PI/6, 5*TWO_PI/6); pop();
        push(); rotate(TWO_PI/6); arc(0, 0, this.r1, this.r1, 0, TWO_PI/6); arc(0, 0, this.r1, this.r1, 2*TWO_PI/6, 3*TWO_PI/6); arc(0, 0, this.r1, this.r1, 4*TWO_PI/6, 5*TWO_PI/6); pop();
        pop();
      }
    }

    // ... existing global variables ...
    let vehicles = [];
    let targetCircleX = [], targetCircleY = [];
    let targetCodeX = [], targetCodeY = [];
    let targetAnimationWordX = [], targetAnimationWordY = [];
    let targetAnimationRectX = [], targetAnimationRectY = [];
    let targetDesignWordX = [], targetDesignWordY = [];
    let targetDesignCirclesX = [], targetDesignCirclesY = [];
    let targetGridX = [], targetGridY = [];

    const COLOR_MAP = {
      'grid_code': [0, 175, 190, 255], 
      'grid_animation': [220, 220, 220, 255], 
      'grid_design': [50, 200, 150, 255], 
      'grid_extra': [255, 60, 60, 255], 
      'circle': [255, 255, 255, 255]
    };
    
    let currentFormation = 'circle'; 
    let particleTargetColor = COLOR_MAP['circle']; 
    let particleCurrentColor = [...particleTargetColor]; 
    let isLightTheme = false; 
 
    let numVehicles = 0; 
    let particleAnimationData;
    let particleDesignData; 
    
    let animationButton, codeButton, designButton, extraButton, backButton;
    
    let isHoveringAnimation = false, isHoveringCode = false, isHoveringDesign = false, isHoveringExtra = false;
    let wasHoveringAnimation = false, wasHoveringCode = false, wasHoveringDesign = false, wasHoveringExtra = false;

    let scale;
    let formationOffsetY = 0;
    let videoTopY = 0, videoHeight = 0;
    
    const FALLBACK_POINT_COUNT = 2300;
    const SVG_TARGET_SIZE = 400; 
    const SVG_VIEW_SCALE = 0.6; 

    function preload() {
      const timeStamp = "?v=" + Date.now(); 
      console.log("Loading all particle data from JSON...");
      
      const animationDataUrl = "https://raw.githubusercontent.com/colinwillow/json_files/main/animation.json" + timeStamp;
      particleAnimationData = loadJSON(animationDataUrl, () => console.log("Animation data loaded."));

      const designDataUrl = "https://raw.githubusercontent.com/colinwillow/json_files/main/design.json" + timeStamp;
      particleDesignData = loadJSON(designDataUrl, () => console.log("Design data loaded."));
    }

    // ... existing data generation functions (generateCircleData, loadCodeData, etc.) ...
    // (Shortened for brevity - keeping logic identical)
    function generateCircleData() {
      targetCircleX = []; targetCircleY = [];
      let maxRadius = 140;
      for (let j = 0; j < numVehicles; j++) {
        let r = maxRadius * sqrt(random(1)); 
        let angle = random(TWO_PI);
        targetCircleX[j] = cos(angle) * r; targetCircleY[j] = sin(angle) * r;
      }
    }

    function loadCodeData() {
      targetCodeX = []; targetCodeY = [];
      const svgElement = document.getElementById('coding-svg');
      if (!svgElement) return;
      const paths = svgElement.querySelectorAll('path');
      let totalSvgLength = 0;
      for (const path of paths) totalSvgLength += path.getTotalLength();
      if (totalSvgLength === 0) {
         while (targetCodeX.length < numVehicles) { targetCodeX.push(random(-100, 100)); targetCodeY.push(random(-100, 100)); }
         return;
      }
      for (const path of paths) {
        const pathLength = path.getTotalLength();
        if (pathLength === 0) continue;
        const pointsToSample = Math.round((pathLength / totalSvgLength) * numVehicles);
        for (let i = 0; i < pointsToSample; i++) {
          const l = (i / Math.max(1, pointsToSample - 1)) * pathLength;
          const pt = path.getPointAtLength(l);
          targetCodeX.push(pt.x); targetCodeY.push(pt.y);
        }
      }
      while (targetCodeX.length < numVehicles && targetCodeX.length > 0) {
        targetCodeX.push(targetCodeX[targetCodeX.length - 1]); targetCodeY.push(targetCodeY[targetCodeY.length - 1]);
      }
      normalizeCodeData();
    }

    function loadAnimationWordData() {
      targetAnimationWordX = []; targetAnimationWordY = [];
      const svgElement = document.getElementById('motion-svg');
      if (!svgElement) return;
      const paths = svgElement.querySelectorAll('path');
      let totalSvgLength = 0;
      for (const path of paths) totalSvgLength += path.getTotalLength();
      if (totalSvgLength === 0) {
         while (targetAnimationWordX.length < numVehicles) { targetAnimationWordX.push(random(-100, 100)); targetAnimationWordY.push(random(-100, 100)); }
         return;
      }
      for (const path of paths) {
        const pathLength = path.getTotalLength();
        if (pathLength === 0) continue;
        const pointsToSample = Math.round((pathLength / totalSvgLength) * numVehicles);
        for (let i = 0; i < pointsToSample; i++) {
          const l = (i / Math.max(1, pointsToSample - 1)) * pathLength;
          const pt = path.getPointAtLength(l);
          targetAnimationWordX.push(pt.x); targetAnimationWordY.push(pt.y);
        }
      }
      while (targetAnimationWordX.length < numVehicles && targetAnimationWordX.length > 0) {
        targetAnimationWordX.push(targetAnimationWordX[targetAnimationWordX.length - 1]); targetAnimationWordY.push(targetAnimationWordY[targetAnimationWordY.length - 1]);
      }
      normalizeAnimationWordData();
    }
    
    function loadDesignData() {
        if (!particleDesignData) return;
        targetDesignWordX = []; targetDesignWordY = [];
        let dataArray = [];
        if (Array.isArray(particleDesignData)) {
            dataArray = particleDesignData; 
        } else if (typeof particleDesignData === 'object' && particleDesignData !== null) {
            const objectVals = Object.values(particleDesignData);
            let successfullyAggregated = false;
            for (const val of objectVals) {
                if (Array.isArray(val) && val.length > 0) {
                    const firstItem = val[0];
                    if ( (Array.isArray(firstItem) && firstItem.length >= 2) || (typeof firstItem === 'object' && firstItem !== null && 'x' in firstItem && 'y' in firstItem) ) {
                         dataArray = dataArray.concat(val); successfullyAggregated = true;
                    }
                }
            }
            if (!successfullyAggregated) {
                const firstVal = objectVals[0];
                 if (objectVals.length > 0 && typeof firstVal === 'object' && firstVal !== null && 'x' in firstVal && 'y' in firstVal) {
                    dataArray = objectVals;
                 }
            }
        }
        const loadCount = min(dataArray.length, numVehicles); 
        if (loadCount === 0 || dataArray.length === 0) return;
        const firstPoint = dataArray[0]; 
        let format = "unknown";
        if (Array.isArray(firstPoint) && firstPoint.length >= 2) { format = "array"; } 
        else if (typeof firstPoint === 'object' && firstPoint !== null && 'x' in firstPoint && 'y' in firstPoint) { format = "object"; }
        if (format === "unknown") return;
        for (let j = 0; j < loadCount; j++) {
            let x, y;
            const point = dataArray[j];
            if (format === "array") { x = point[0]; y = point[1]; } 
            else { x = point.x; y = point.y; }
            targetDesignWordX.push(x); targetDesignWordY.push(y);
        }
        normalizeDesignData();
    }
    
    function normalizeDesignData() {
        if (targetDesignWordX.length === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (let i = 0; i < targetDesignWordX.length; i++) {
            minX = min(minX, targetDesignWordX[i]); minY = min(minY, targetDesignWordY[i]);
            maxX = max(maxX, targetDesignWordX[i]); maxY = max(maxY, targetDesignWordY[i]);
        }
        const shapeWidth = maxX - minX; const shapeHeight = maxY - minY;
        const offsetX = (minX + maxX) / 2; const offsetY = (minY + maxY) / 2;
        const maxDim = max(shapeWidth, shapeHeight);
        const normalizeScale = (maxDim > 0) ? SVG_TARGET_SIZE / maxDim : 1;
        for (let i = 0; i < targetDesignWordX.length; i++) {
            targetDesignWordX[i] = (targetDesignWordX[i] - offsetX) * normalizeScale;
            targetDesignWordY[i] = (targetDesignWordY[i] - offsetY) * normalizeScale;
        }
    }
    
    function normalizeCodeData() {
        if (targetCodeX.length === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (let i = 0; i < targetCodeX.length; i++) {
            minX = min(minX, targetCodeX[i]); minY = min(minY, targetCodeY[i]);
            maxX = max(maxX, targetCodeX[i]); maxY = max(maxY, targetCodeY[i]);
        }
        const shapeWidth = maxX - minX; const shapeHeight = maxY - minY;
        const offsetX = (minX + maxX) / 2; const offsetY = (minY + maxY) / 2;
        const maxDim = max(shapeWidth, shapeHeight);
        const normalizeScale = (maxDim > 0) ? SVG_TARGET_SIZE / maxDim : 1;
        for (let i = 0; i < targetCodeX.length; i++) {
            targetCodeX[i] = (targetCodeX[i] - offsetX) * normalizeScale;
            targetCodeY[i] = (targetCodeY[i] - offsetY) * normalizeScale;
        }
    }
    
    function normalizeAnimationWordData() {
        if (targetAnimationWordX.length === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (let i = 0; i < targetAnimationWordX.length; i++) {
            minX = min(minX, targetAnimationWordX[i]); minY = min(minY, targetAnimationWordY[i]);
            maxX = max(maxX, targetAnimationWordX[i]); maxY = max(maxY, targetAnimationWordY[i]);
        }
        const shapeWidth = maxX - minX; const shapeHeight = maxY - minY;
        const offsetX = (minX + maxX) / 2; const offsetY = (minY + maxY) / 2;
        const maxDim = max(shapeWidth, shapeHeight);
        const normalizeScale = (maxDim > 0) ? SVG_TARGET_SIZE / maxDim : 1;
        for (let i = 0; i < targetAnimationWordX.length; i++) {
            targetAnimationWordX[i] = (targetAnimationWordX[i] - offsetX) * normalizeScale;
            targetAnimationWordY[i] = (targetAnimationWordY[i] - offsetY) * normalizeScale;
        }
    }
    
    window.generateConcentricCircleData = function() {
      targetDesignCirclesX = []; targetDesignCirclesY = [];
      const numRings = 15; const minRadius = 400; const maxRadius = 700; 
      const ringSpacing = (maxRadius - minRadius) / (numRings > 1 ? numRings - 1 : 1);
      const particlesPerRing = Math.ceil(numVehicles / numRings);
      let particleCount = 0;
      for (let ring = 0; ring < numRings; ring++) {
          const radius = minRadius + (ring * ringSpacing);
          const currentParticles = Math.min(particlesPerRing, numVehicles - particleCount);
          for (let i = 0; i < currentParticles; i++) {
              if (particleCount >= numVehicles) break;
              const angle = (i / currentParticles) * TWO_PI; 
              targetDesignCirclesX.push(cos(angle) * radius); targetDesignCirclesY.push(sin(angle) * radius);
              particleCount++;
          }
      }
    }
    
    window.generateAnimationRectData = function() {
      targetAnimationRectX = []; targetAnimationRectY = [];
      const numRects = 2; const aspectRatio = 16 / 9; const padding = 40; const inset = 20; 
      let outerW = width - padding; let outerH = outerW / aspectRatio;
      if (outerH > height - 80) { outerH = height - 80; outerW = outerH * aspectRatio; }
      let innerW = outerW - (inset * 2); let innerH = outerH - (inset * 2);
      const rects = [ { w: outerW, h: outerH }, { w: innerW, h: innerH } ];
      const particlesPerRect = Math.ceil(numVehicles / numRects);
      let totalPointsGenerated = 0;
      for (let i = 0; i < numRects; i++) {
          const w = rects[i].w; const h = rects[i].h; const perimeter = 2 * (w + h);
          let pointsForThisRect = Math.min(particlesPerRect, numVehicles - totalPointsGenerated);
          if (i === numRects - 1) { pointsForThisRect = numVehicles - totalPointsGenerated; }
          if (pointsForThisRect <= 0) break;
          for (let j = 0; j < pointsForThisRect; j++) {
              const fraction = j / pointsForThisRect; let x, y;
              const p_fraction = fraction * perimeter; 
              if (p_fraction < w) { x = map(p_fraction, 0, w, -w / 2, w / 2); y = -h / 2; } 
              else if (p_fraction < w + h) { x = w / 2; y = map(p_fraction, w, w + h, -h / 2, h / 2); } 
              else if (p_fraction < 2 * w + h) { x = map(p_fraction, w + h, 2 * w + h, w / 2, -w / 2); y = h / 2; } 
              else { x = -w / 2; y = map(p_fraction, 2 * w + h, perimeter, h / 2, -h / 2); }
              targetAnimationRectX.push(x); targetAnimationRectY.push(y);
              totalPointsGenerated++;
          }
      }
      while (targetAnimationRectX.length < numVehicles) {
          targetAnimationRectX.push(random(-25, 25)); targetAnimationRectY.push(random(-25, 25));
      }
    }
    
    function updateVideoSize() {
      const video = document.getElementById('animation-video');
      if (!video) return;
      const aspectRatio = 16 / 9; const padding = 40; 
      let outerW = width - padding; let outerH = outerW / aspectRatio;
      if (outerH > height - 80) { outerH = height - 80; outerW = outerH * aspectRatio; }
      video.style.width = `${outerW}px`; video.style.height = `${outerH}px`;
      videoHeight = outerH; videoTopY = (height - videoHeight) / 2;
    }

    window.generateNormalizedGridData = function() {
      targetGridX = []; targetGridY = [];
      const GRID_DIMENSION = 1000; const GRID_COLS = 100; 
      const totalPoints = numVehicles; const effective_rows = ceil(totalPoints / GRID_COLS);
      const spacing_x = GRID_DIMENSION / GRID_COLS; const start_x = -GRID_DIMENSION / 2; 
      let count = 0;
      for (let r = 0; r < effective_rows; r++) {
          for (let c = 0; c < GRID_COLS; c++) {
              if (count < totalPoints) {
                  const x = start_x + c * spacing_x + (spacing_x / 2); 
                  const norm_r = effective_rows > 1 ? r / (effective_rows - 1) : 0.5;
                  const y = map(norm_r, 0, 1, -GRID_DIMENSION / 2, GRID_DIMENSION / 2);
                  targetGridX.push(x); targetGridY.push(y); count++;
              } else { break; }
          }
          if (count >= totalPoints) break;
      }
      while (targetGridX.length < numVehicles) { targetGridX.push(0); targetGridY.push(0); }
    }
    
    function repositionButtons() {
      let buttonY = height - 70; let buttonW = 180; let buttonH = 30; let spacing = 150; let animButtonRadius = 30; 
      if (!animationButton) { animationButton = new AnimatedButton(width / 2 - spacing * 1.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_animation'])); } 
      else { animationButton.x = width / 2 - spacing * 1.5; animationButton.y = buttonY; }
      if (!codeButton) { codeButton = new AnimatedButton(width / 2 - spacing * 0.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_code'])); } 
      else { codeButton.x = width / 2 - spacing * 0.5; codeButton.y = buttonY; }
      if (!designButton) { designButton = new AnimatedButton(width / 2 + spacing * 0.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_design'])); } 
      else { designButton.x = width / 2 + spacing * 0.5; designButton.y = buttonY; }
      if (!extraButton) { extraButton = new AnimatedButton(width / 2 + spacing * 1.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_extra'])); } 
      else { extraButton.x = width / 2 + spacing * 1.5; extraButton.y = buttonY; }
      if (!backButton) { backButton = new SpaceButton(width / 2, 40, buttonW, buttonH, color(255, 255, 255, 255)); } 
      else { backButton.x = width / 2; backButton.y = 40; }
    }
  
    function initializeParticles() {
        console.log("Starting particle initialization...");
        let animValues = [];
        if (particleAnimationData) {
            if (Array.isArray(particleAnimationData)) { animValues = particleAnimationData; } 
            else if (typeof particleAnimationData === 'object' && particleAnimationData !== null) {
                const objectVals = Object.values(particleAnimationData);
                let successfullyAggregated = false;
                for (const val of objectVals) {
                    if (Array.isArray(val) && val.length > 0) {
                        const firstItem = val[0];
                        if ( (Array.isArray(firstItem) && firstItem.length >= 2) || (typeof firstItem === 'object' && firstItem !== null && 'x' in firstItem && 'y' in firstItem) || (typeof firstItem === 'object' && firstItem !== null && Object.values(firstItem).length >= 3) || (typeof firstItem === 'object' && firstItem !== null && 'X' in firstItem && 'Y' in firstItem) ) {
                             animValues = animValues.concat(val); successfullyAggregated = true;
                        }
                    }
                }
                if (!successfullyAggregated) {
                    const firstVal = objectVals[0];
                     if (objectVals.length > 0 && typeof firstVal === 'object' && firstVal !== null && ('x' in firstVal && 'y' in firstVal || Object.values(firstVal).length >= 3 || 'X' in firstVal && 'Y' in firstVal)) {
                        animValues = objectVals;
                     }
                }
            }
        }
        let designValues = [];
        if (particleDesignData) {
            if (Array.isArray(particleDesignData)) { designValues = particleDesignData; } 
            else if (typeof particleDesignData === 'object' && particleDesignData !== null) {
                const objectVals = Object.values(particleDesignData);
                let successfullyAggregated = false;
                for (const val of objectVals) {
                    if (Array.isArray(val) && val.length > 0) {
                        const firstItem = val[0];
                        if ( (Array.isArray(firstItem) && firstItem.length >= 2) || (typeof firstItem === 'object' && firstItem !== null && 'x' in firstItem && 'y' in firstItem) ) {
                             designValues = designValues.concat(val); successfullyAggregated = true;
                        }
                    }
                }
                if (!successfullyAggregated) {
                    const firstVal = objectVals[0];
                     if (objectVals.length > 0 && typeof firstVal === 'object' && firstVal !== null && 'x' in firstVal && 'y' in firstVal) {
                        designValues = objectVals; 
                     }
                }
            }
        }

        const animLen = animValues.length;
        const designLen = designValues.length; 

        const allLengths = [];
        if (animLen > 0) allLengths.push(animLen);
        if (designLen > 0) allLengths.push(designLen);

        if (allLengths.length > 0) {
            numVehicles = max(allLengths); 
        } else {
            console.warn("No JSON data loaded! Using fallback count.");
            numVehicles = FALLBACK_POINT_COUNT; 
        }

        console.log(`All data loaded. Using largest count: ${numVehicles} particles.`);
        
        loadCodeData(); loadAnimationWordData(); loadDesignData(); 
        generateCircleData(); generateNormalizedGridData(); 
        generateConcentricCircleData(); generateAnimationRectData(); 
        loadVehicles();
        
        let buttonY = height - 70; let buttonW = 180; let buttonH = 30; let spacing = 150; let animButtonRadius = 30;
        animationButton = new AnimatedButton(width / 2 - spacing * 1.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_animation']));
        codeButton = new AnimatedButton(width / 2 - spacing * 0.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_code']));
        designButton = new AnimatedButton(width / 2 + spacing * 0.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_design'])); 
        extraButton = new AnimatedButton(width / 2 + spacing * 1.5, buttonY, animButtonRadius, color(COLOR_MAP['grid_extra'])); 
        backButton = new SpaceButton(width / 2, 40, buttonW, buttonH, color(255, 255, 255, 255)); 
    
        rectMode(CENTER); textAlign(CENTER); scale = 1.5;
        window.isInitialized = true;
    }

    function setup() {
      let p5Canvas = createCanvas(windowWidth, windowHeight);
      p5Canvas.parent('p5-canvas-container'); 
      initializeParticles(); updateVideoSize(); 
      
      const portalVideo = document.getElementById('portal-video');
      if (portalVideo) {
        portalVideo.style.display = 'block';
        portalVideo.play().catch(e => console.warn("Portal video autoplay was blocked."));
      }
      
      const themeToggle = document.getElementById('theme-toggle-input');
      if (themeToggle) {
        themeToggle.addEventListener('change', function() {
            isLightTheme = this.checked;
            document.body.classList.toggle('light-theme', isLightTheme);
        });
      }
      
      if (typeof window.updateButtonPositions === 'function') {
          console.log("p5 setup: Triggering initial button position.");
          setTimeout(window.updateButtonPositions, 100); 
      }
      
      noiseDetail(8, 0.5); 
    }

    function loadVehicles() {
      for (var j = 0; j < numVehicles; j++) {
        var v = new Vehicle(random(width), random(height), random(1, 7));
        vehicles.push(v);
      }
    }

    function resetToCircleMode() {
        currentFormation = 'circle';
        animationButton.isActive = false; codeButton.isActive = false; designButton.isActive = false; extraButton.isActive = false; 
        particleTargetColor = COLOR_MAP['circle'];
        
        const video = document.getElementById('animation-video');
        if (video) { video.style.display = 'none'; video.pause(); video.currentTime = 0; }
        const portalVideo = document.getElementById('portal-video');
        if (portalVideo) { portalVideo.style.display = 'block'; portalVideo.play().catch(e => console.warn("Portal video play was blocked.")); }
        const buttonContainer = document.getElementById('portal-button-container');
        if (buttonContainer) { buttonContainer.style.display = 'block'; }
        console.log("Reset to 'circle' mode.");
    }
    
    function setGridMode(mode) {
        currentFormation = mode; particleTargetColor = COLOR_MAP[mode];
        animationButton.isActive = (mode === 'grid_animation'); codeButton.isActive = (mode === 'grid_code'); designButton.isActive = (mode === 'grid_design'); extraButton.isActive = (mode === 'grid_extra'); 
        const portalVideo = document.getElementById('portal-video');
        if (portalVideo) { portalVideo.style.display = 'none'; portalVideo.pause(); portalVideo.currentTime = 0; }
        const buttonContainer = document.getElementById('portal-button-container');
        if (buttonContainer) { buttonContainer.style.display = 'none'; }
        const video = document.getElementById('animation-video');
        if (video) {
          if (mode === 'grid_animation') { video.style.display = 'block'; video.play(); } 
          else { video.style.display = 'none'; video.pause(); video.currentTime = 0; }
        }
        for (const v of vehicles) { v.sizeWord(); }
        console.log(`Switched to permanent '${mode}' mode.`);
    }

    function mousePressed() {
      if (!window.isInitialized) return;
      if (backButton && backButton.isHovered()) { resetToCircleMode(); return; }
      if (animationButton && animationButton.isHovered() && currentFormation !== 'grid_animation') { setGridMode('grid_animation'); } 
      else if (codeButton && codeButton.isHovered() && currentFormation !== 'grid_code') { setGridMode('grid_code'); } 
      else if (designButton && designButton.isHovered() && currentFormation !== 'grid_design') { setGridMode('grid_design'); } 
      else if (extraButton && extraButton.isHovered() && currentFormation !== 'grid_extra') { setGridMode('grid_extra'); }
    }
    
    window.onresize = function() {
      if (!window.isInitialized) return;
      resizeCanvas(window.innerWidth, window.innerHeight);
      repositionButtons();
      generateNormalizedGridData(); generateConcentricCircleData(); generateAnimationRectData();
      updateVideoSize(); normalizeDesignData(); 
      if (typeof window.updateButtonPositions === 'function') { window.updateButtonPositions(); }
    };

    function draw() {
      if (!window.isInitialized) {
          background(0); fill(255); textAlign(CENTER, CENTER); textSize(32); text("Loading Particle Data...", width / 2, height / 2);
          return;
      }
      for (let i = 0; i < 4; i++) { particleCurrentColor[i] = lerp(particleCurrentColor[i], particleTargetColor[i], 0.05); }
      if (currentFormation === 'circle' || currentFormation === 'grid_animation') { clear(); } 
      else {
          let bgR, bgG, bgB;
          if (isLightTheme) { bgR = 245; bgG = 245; bgB = 245; } else { bgR = 32; bgG = 32; bgB = 32; }
          background(bgR, bgG, bgB, 40); 
      }
      scale = 0.5 * width / 540;
      let oscillationSpeed = 0.03; let oscillationAmplitude = 15; 
      let defaultOffsetY = sin(frameCount * oscillationSpeed) * oscillationAmplitude; 
      formationOffsetY = defaultOffsetY; 
      if (currentFormation === 'circle') { formationOffsetY += -50; }

      let isHoveringAnimation = animationButton && animationButton.isHovered() && currentFormation !== 'grid_animation';
      let isHoveringCode = codeButton && codeButton.isHovered() && currentFormation !== 'grid_code';
      let isHoveringDesign = designButton && designButton.isHovered() && currentFormation !== 'grid_design';
      let isHoveringExtra = extraButton && extraButton.isHovered() && currentFormation !== 'grid_extra';      
      
      if (typeof window.triggerPurpleButton === 'function' && isHoveringAnimation !== wasHoveringAnimation) { window.triggerPurpleButton(isHoveringAnimation); }
      wasHoveringAnimation = isHoveringAnimation; 

      if (typeof window.triggerGreenButton === 'function' && isHoveringCode !== wasHoveringCode) { window.triggerGreenButton(isHoveringCode); }
      wasHoveringCode = isHoveringCode; 

      if (typeof window.triggerBlueButton === 'function' && isHoveringDesign !== wasHoveringDesign) { window.triggerBlueButton(isHoveringDesign); }
      wasHoveringDesign = isHoveringDesign; 

      if (typeof window.triggerRedButton === 'function' && isHoveringExtra !== wasHoveringExtra) { window.triggerRedButton(isHoveringExtra); }
      wasHoveringExtra = isHoveringExtra; 

      const isAnyHover = isHoveringAnimation || isHoveringCode || isHoveringDesign || isHoveringExtra;
      const particleColorShouldBeOverriden = currentFormation.startsWith('grid') && !isAnyHover && currentFormation !== 'grid_animation';
      let currentGlobalOffsetY = formationOffsetY; 

      for (var i = 0; i < vehicles.length; i++) {
        var v = vehicles[i];
        v.isWordParticle = false; 
        let target_x, target_y;
        v.setScale(1.0); 
        const getTargetIndex = (index, length) => index % length;

        if (isHoveringAnimation) {
            if (i % 4 !== 0) { 
                v.isWordParticle = true; v.sizeWord();
                const animationIndex = getTargetIndex(i, targetAnimationWordX.length);
                target_x = targetAnimationWordX[animationIndex] * SVG_VIEW_SCALE + width / 2;
                target_y = targetAnimationWordY[animationIndex] * SVG_VIEW_SCALE + height / 2 + currentGlobalOffsetY; 
            } else {
                v.sizeBall();
                const circleIndex = getTargetIndex(i, targetCircleX.length);
                const squigX = sin(frameCount / 10000.0 * i); const squigY = cos(frameCount / 20000.0 * i);
                target_x = targetCircleX[circleIndex] * squigX * scale * 0.8 + width / 2;
                target_y = targetCircleY[circleIndex] * squigY * scale * 0.8 + height / 2 + currentGlobalOffsetY;
            }
        } else if (isHoveringCode) {
            if (i % 4 !== 0) { 
                v.isWordParticle = true; v.sizeWord(); 
                const codeIndex = getTargetIndex(i, targetCodeX.length);
                target_x = targetCodeX[codeIndex] * SVG_VIEW_SCALE + width / 2; 
                target_y = targetCodeY[codeIndex] * SVG_VIEW_SCALE + height / 2 + currentGlobalOffsetY; 
            } else {
                v.sizeBall();
                const circleIndex = getTargetIndex(i, targetCircleX.length);
                const squigX = sin(frameCount / 10000.0 * i); const squigY = cos(frameCount / 20000.0 * i);
                target_x = targetCircleX[circleIndex] * squigX * scale * 0.8 + width / 2;
                target_y = targetCircleY[circleIndex] * squigY * scale * 0.8 + height / 2 + currentGlobalOffsetY;
            }
        } else if (isHoveringDesign) { 
            if (i % 4 !== 0) { 
                v.isWordParticle = true; v.sizeWord();
                const designIndex = getTargetIndex(i, targetDesignWordX.length); 
                target_x = targetDesignWordX[designIndex] * SVG_VIEW_SCALE + width / 2; 
                target_y = targetDesignWordY[designIndex] * SVG_VIEW_SCALE + height / 2 + currentGlobalOffsetY; 
            } else {
                v.sizeBall();
                const circleIndex = getTargetIndex(i, targetCircleX.length);
                const squigX = sin(frameCount / 10000.0 * i); const squigY = cos(frameCount / 20000.0 * i);
                target_x = targetCircleX[circleIndex] * squigX * scale * 0.8 + width / 2;
                target_y = targetCircleY[circleIndex] * squigY * scale * 0.8 + height / 2 + currentGlobalOffsetY;
            }
        } else if (isHoveringExtra) { 
            if (i % 4 !== 0) {
                v.isWordParticle = true; v.sizeWord();
                const designIndex = getTargetIndex(i, targetDesignWordX.length); 
                target_x = targetDesignWordX[designIndex] * SVG_VIEW_SCALE + width / 2;
                target_y = targetDesignWordY[designIndex] * SVG_VIEW_SCALE + height / 2 + currentGlobalOffsetY;
            } else {
                v.sizeBall();
                const circleIndex = getTargetIndex(i, targetCircleX.length);
                const squigX = sin(frameCount / 10000.0 * i); const squigY = cos(frameCount / 20000.0 * i);
                target_x = targetCircleX[circleIndex] * squigX * scale * 0.8 + width / 2;
                target_y = targetCircleY[circleIndex] * squigY * scale * 0.8 + height / 2 + currentGlobalOffsetY;
            }
        } else if (currentFormation === 'grid_animation') {
            v.sizeWord();
            const rectIndex = getTargetIndex(i, targetAnimationRectX.length);
            target_x = targetAnimationRectX[rectIndex] * scale + width / 2;
            target_y = targetAnimationRectY[rectIndex] * scale + height / 2 + formationOffsetY; 
        } else if (currentFormation === 'grid_code') {
            v.sizeWord();
            const gridIndex = getTargetIndex(i, targetGridX.length);
            const base_x = targetGridX[gridIndex]; const base_y = targetGridY[gridIndex];
            const base_screen_x = base_x * scale + width / 2; const base_screen_y = base_y * scale + height / 2;
            const noise_val = noise(base_screen_x * 0.005, base_screen_y * 0.005 + frameCount * 0.005);
            const height_offset = map(noise_val, 0.2, 0.8, -150, 150);
            const height_offset_scaled = height_offset * scale;
            target_x = base_screen_x; target_y = base_screen_y + height_offset_scaled + formationOffsetY; 
            const z_pos = height_offset; const normalized_z = map(z_pos, -150, 150, 0.5, 1.5); 
            v.setScale(normalized_z);
        } else if (currentFormation === 'grid_design') {
            v.sizeWord();
            const designCircleIndex = getTargetIndex(i, targetDesignCirclesX.length);
            target_x = targetDesignCirclesX[designCircleIndex] * scale + width / 2; 
            target_y = targetDesignCirclesY[designCircleIndex] * scale + height / 2 + formationOffsetY; 
        } else if (currentFormation === 'grid_extra') {
            v.sizeWord();
            const designCircleIndex = getTargetIndex(i, targetDesignCirclesX.length);
            target_x = targetDesignCirclesX[designCircleIndex] * scale + width / 2; 
            target_y = targetDesignCirclesY[designCircleIndex] * scale + height / 2 + formationOffsetY;
        } else { 
            v.sizeBall(); 
            const circleIndex = getTargetIndex(i, targetCircleX.length);
            const squigX = sin(frameCount / 10000.0 * i); const squigY = cos(frameCount / 20000.0 * i);
            target_x = targetCircleX[circleIndex] * squigX * scale + width / 2;
            target_y = targetCircleY[circleIndex] * squigY * scale + height / 2 + formationOffsetY; 
        }
        
        v.update(target_x, target_y);
        
        if (isAnyHover) {
            if (i % 4 === 0) { v.show(false, isAnyHover, null); }
        } else {
            v.show(particleColorShouldBeOverriden, isAnyHover, null); 
        }
        v.behaviors();
      }

      if (isAnyHover) {
          let hoverColor = null;
          if (isLightTheme) {
              if (isHoveringAnimation) { hoverColor = color(180, 140, 210, 255); } 
              else if (isHoveringCode) { hoverColor = color(130, 200, 150, 255); } 
              else if (isHoveringDesign) { hoverColor = color(130, 170, 220, 255); } 
              else if (isHoveringExtra) { hoverColor = color(220, 130, 130, 255); }
          } else {
              if (isHoveringAnimation) { hoverColor = color(210, 178, 248, 255); } 
              else if (isHoveringCode) { hoverColor = color(168, 255, 192, 255); } 
              else if (isHoveringDesign) { hoverColor = color(168, 212, 255, 255); } 
              else if (isHoveringExtra) { hoverColor = color(255, 168, 168, 255); }
          }
          for (var i = 0; i < vehicles.length; i++) {
              if (i % 4 !== 0) { var v = vehicles[i]; v.show(false, isAnyHover, hoverColor); }
          }
      }

      push(); rectMode(CENTER);
      if (isLightTheme) { fill(230, 230, 230, 200); } else { fill(50, 50, 50, 150); }
      noStroke(); rect(width / 2, 40, width - 40, 80, 10); 
      pop();

      push(); rectMode(CENTER);
      if (isLightTheme) { fill(230, 230, 230, 200); } else { fill(50, 50, 50, 150); }
      noStroke(); rect(width / 2, height - 70, width - 40, 80, 10); 
      pop();

      if (backButton) backButton.show();
      if (animationButton) animationButton.show();
      if (codeButton) codeButton.show();
      if (designButton) designButton.show();
      if (extraButton) extraButton.show();       

      push(); textSize(20); fill(255, 100); noStroke();
      let displayMode = currentFormation.replace('grid_', '').toUpperCase();
      if (currentFormation === 'circle') { displayMode = 'PORTAL MODE (HOVER FOR PREVIEW)'; } 
      else if (currentFormation === 'grid_design') { displayMode = 'DESIGN CIRCLES'; } 
      else if (currentFormation === 'grid_animation') { displayMode = 'ANIMATION SCREENS (CONCENTRIC)'; } 
      else if (currentFormation === 'grid_code') { displayMode = 'CODE TERRAIN (ANIMATED GRID)'; } 
      else if (currentFormation === 'grid_extra') { displayMode = 'EXTRA MODE (PLACEHOLDER)'; }
      pop();
    }

    // ... Vehicle class and prototypes ...
    function Vehicle(x, y, r) {
      this.position = createVector(x, y); this.velocity = createVector(0, 0); this.acceleration = createVector(0, 0);
      this.mouse = createVector(mouseX, mouseY);
      this.sizeL = 1; this.sizeH = 4; this.sizeL2 = 1; this.sizeH2 = 4;
      this.projectionScale = 1.0; this.isWordParticle = false;
      this.lerpedColor = color(0, 0, 0, 0); this.isFirstColorUpdate = true;
      this.maxSpeed = random(11, 12); this.maxForce = this.maxSpeed * 0.05; this.r = r;
    }
    Vehicle.prototype.update = function (x, y, z) {
      this.position.add(this.velocity); this.velocity.add(this.acceleration); this.acceleration.mult(0);
      this.target = createVector(x, y, z);
      this.sizeL = lerp(this.sizeL, this.sizeL2, 0.05); this.sizeH = lerp(this.sizeH, this.sizeH2, 0.05);
    }
    Vehicle.prototype.setScale = function (scale) { this.projectionScale = scale; }
    Vehicle.prototype.sizeBall = function () { this.sizeL2 = 2; this.sizeH2 = 10; }
    Vehicle.prototype.sizeWord = function () { this.sizeL2 = 4; this.sizeH2 = 4; }
    Vehicle.prototype.show = function (isColorOverriden, isAnyHover, wordColorOverride) {
      var origin = createVector(width / 2, height / 2); var vel = this.velocity.mag();
      var distance = origin.sub(this.position); var distMag = distance.mag();
      var size; 
      push(); noStroke(); translate(this.position.x, this.position.y);
      if (isColorOverriden) {
          fill(particleCurrentColor[0], particleCurrentColor[1], particleCurrentColor[2], particleCurrentColor[3]);
          if (currentFormation === 'grid_code') { size = this.sizeL * this.projectionScale * 1.0; } 
          else if (currentFormation === 'grid_design') { size = this.sizeL * this.projectionScale * 1.0; } 
          else if (currentFormation === 'grid_extra') { size = this.sizeL * this.projectionScale * 1.0; } 
          else { size = this.sizeL * this.projectionScale * 2.0; }
          ellipse(0, 0, size, size);
      } else {
          let colR, colG, colB, alpha; let targetFillColor; 
          if (this.isWordParticle) {
              if (wordColorOverride) { targetFillColor = wordColorOverride; } 
              else { if (isLightTheme) { targetFillColor = color(50, 50, 50, 255); } else { targetFillColor = color(255, 255, 255, 255); } }
              if (this.isFirstColorUpdate) { this.lerpedColor = targetFillColor; this.isFirstColorUpdate = false; } 
              else { this.lerpedColor = lerpColor(this.lerpedColor, targetFillColor, 0.1); }
              fill(this.lerpedColor); 
              let clampedDist = min(distMag, 100); size = map(clampedDist, 100, 0, this.sizeL, this.sizeH); 
          } else {
              if (isLightTheme) { colR = map(this.velocity.x, 0, 10, 100, 50); colG = map(this.velocity.y, 0, 10, 120, 100); colB = map(vel, 0, 10, 150, 120); } 
              else { colR = map(this.velocity.x, 0, 10, 230, 51); colG = map(this.velocity.y, 0, 10, 220, 151); colB = map(vel, 0, 10, 250, 134); }
              if (isAnyHover) { alpha = map(vel, 0, 20, 100, 0); let clampedDist = min(distMag, 100); size = map(clampedDist, 100, 0, this.sizeL, this.sizeH) * 0.5; } 
              else { alpha = map(vel, 0, 20, 200, 00); let clampedDist = min(distMag, 100); size = map(clampedDist, 100, 0, this.sizeL, this.sizeH); }
              targetFillColor = color(colR * 0.96 - 50 - 20, colG * 0.98 - 20, colB * 1.3 + 50 - 20, alpha);
              if (this.isFirstColorUpdate) { this.lerpedColor = targetFillColor; this.isFirstColorUpdate = false; } 
              else { this.lerpedColor = lerpColor(this.lerpedColor, targetFillColor, 0.1); }
              fill(this.lerpedColor); 
              if (currentFormation === 'grid_animation' && !isAnyHover) { size *= 2.0; }
          }
          let rotationFactor = map(distMag, 0, 250, 0.05, 0.005); rotate(frameCount * rotationFactor);
          ellipse(0, 0, size, size);
      }
      pop();
    }
    Vehicle.prototype.flee = function (target) {
      var desired = p5.Vector.sub(target, this.position); var distance = desired.mag();
      if (distance < 100) { desired.setMag(this.maxSpeed); desired.mult(-1); var steer = p5.Vector.sub(desired, this.velocity); steer.limit(this.maxForce); return steer; }
      return createVector(0, 0);
    }
    Vehicle.prototype.arrive = function (target) {
      var desired = p5.Vector.sub(target, this.position); var distance = desired.mag(); var speed = this.maxSpeed;
      if (distance < 500) { speed = map(distance, 0, 100, 0, this.maxSpeed); }
      desired.setMag(speed); var steer = p5.Vector.sub(desired, this.velocity); steer.limit(this.maxForce); return steer;
    }
    Vehicle.prototype.behaviors = function () {
      var arrive = this.arrive(this.target); var mouse = createVector(mouseX, mouseY); var flee = this.flee(mouse);
      arrive.mult(1); flee.mult(2); this.applyForce(arrive); this.applyForce(flee);
    }
    Vehicle.prototype.applyForce = function (force) { this.acceleration.add(force); }
    Vehicle.prototype.edges = function () {
      if (this.position.x <= -width / 2 || this.position.x >= width / 2) { this.velocity.x *= -1; }
      if (this.position.y <= -height / 2 || this.position.y >= height / 2) { this.velocity.y *= -1; }
    }
  </script>

  <!-- --- NEW: Portal Button Animation Script --- -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const purpleButton = document.getElementById('purple-button-seq');
      const greenButton = document.getElementById('green-button-seq'); 
      const blueButton = document.getElementById('blue-button-seq'); 
      const redButton = document.getElementById('red-button-seq'); 
      const portalVideo = document.getElementById('portal-video');

      if (!purpleButton || !greenButton || !blueButton || !redButton || !portalVideo) { 
        console.error("Could not find '#purple-button-seq', '#green-button-seq', '#blue-button-seq', '#red-button-seq', or '#portal-video' element.");
        return;
      }
      
      // --- SHARED SPRITE LOGIC ---
      
      // Store data for all sprites
      const spriteData = {
          purple: { frames: [], meta: null, element: purpleButton },
          green:  { frames: [], meta: null, element: greenButton },
          blue:   { frames: [], meta: null, element: blueButton },
          red:    { frames: [], meta: null, element: redButton }
      };

      // Helper to fetch and parse sprite JSON
      function loadSpriteData(key, url) {
          fetch(url)
            .then(response => response.json())
            .then(data => {
                console.log(`${key} Sprite JSON loaded`);
                if (data && data.meta && data.meta.size) {
                    spriteData[key].meta = data.meta.size;
                }
                if (data && data.frames) {
                    const frameKeys = Object.keys(data.frames).sort();
                    spriteData[key].frames = frameKeys.map(k => ({ name: k, ...data.frames[k] }));
                    // Render first frame immediately
                    renderSpriteFrame(key, 0);
                }
            })
            .catch(err => console.error(`Error loading ${key} sprite JSON:`, err));
      }

      // Load all JSONs
      loadSpriteData('purple', 'https://raw.githubusercontent.com/colinwillow/sprites/main/purple_sprites_coordinates.json');
      loadSpriteData('green', 'https://raw.githubusercontent.com/colinwillow/sprites/main/green_sprites_coordinates.json');
      loadSpriteData('blue', 'https://raw.githubusercontent.com/colinwillow/sprites/main/blue_sprites_coordinates.json');
      loadSpriteData('red', 'https://raw.githubusercontent.com/colinwillow/sprites/main/red_sprites_coordinates.json');

      // --- GENERIC RENDER FUNCTION ---
      function renderSpriteFrame(key, frameIndex) {
          const data = spriteData[key];
          const element = data.element;
          
          if (data.frames.length > 0 && data.meta && element.clientWidth > 0) {
              const safeIndex = Math.min(frameIndex, data.frames.length - 1);
              const frameData = data.frames[safeIndex].frame;
              
              // Calculate ratio based on current HTML element width vs sprite frame width
              const ratio = element.clientWidth / frameData.w;
              
              // Calculate scaled sheet size and offsets
              const bgW = data.meta.w * ratio;
              const bgH = data.meta.h * ratio;
              const posX = frameData.x * ratio;
              const posY = frameData.y * ratio;
              
              element.style.backgroundSize = `${bgW}px ${bgH}px`;
              element.style.backgroundPosition = `-${posX}px -${posY}px`;
          }
      }

      // --- ANIMATION STATE ---
      const TOTAL_FRAMES = 46; 
      const TARGET_FPS = 30;
      const frameDuration = 1000 / TARGET_FPS; 
      
      // State objects for each button
      const animState = {
          purple: { current: 0, target: 0, id: null, lastTime: 0 },
          green:  { current: 0, target: 0, id: null, lastTime: 0 },
          blue:   { current: 0, target: 0, id: null, lastTime: 0 },
          red:    { current: 0, target: 0, id: null, lastTime: 0 }
      };
      
      // Generic Animation Loop Helper
      function animateButton(key) {
          const state = animState[key];
          
          if (state.id) { cancelAnimationFrame(state.id); state.id = null; }

          function step(timestamp) {
              const elapsedTime = timestamp - state.lastTime;

              if (elapsedTime >= frameDuration) {
                  state.lastTime = timestamp - (elapsedTime % frameDuration); 

                  if (state.current < state.target) { state.current++; } 
                  else if (state.current > state.target) { state.current--; }
                  
                  renderSpriteFrame(key, state.current);
              }
              
              if (state.current !== state.target) { 
                  state.id = requestAnimationFrame(step); 
              } else { 
                  state.id = null; 
              }
          }
          state.id = requestAnimationFrame(step);
      }
      
      // --- GLOBAL TRIGGERS (Called from p5.js) ---
      
      window.triggerPurpleButton = function(isHovering) {
        const newTarget = isHovering ? TOTAL_FRAMES : 0;
        if (newTarget !== animState.purple.target) { 
          animState.purple.target = newTarget; 
          animState.purple.lastTime = performance.now(); 
          animateButton('purple'); 
        }
      }
      
      window.triggerGreenButton = function(isHovering) {
        const newTarget = isHovering ? TOTAL_FRAMES : 0;
        if (newTarget !== animState.green.target) { 
          animState.green.target = newTarget; 
          animState.green.lastTime = performance.now(); 
          animateButton('green');
        }
      }
      
      window.triggerBlueButton = function(isHovering) {
        const newTarget = isHovering ? TOTAL_FRAMES : 0;
        if (newTarget !== animState.blue.target) { 
          animState.blue.target = newTarget; 
          animState.blue.lastTime = performance.now(); 
          animateButton('blue');
        }
      }
      
      window.triggerRedButton = function(isHovering) {
        const newTarget = isHovering ? TOTAL_FRAMES : 0;
        if (newTarget !== animState.red.target) { 
          animState.red.target = newTarget; 
          animState.red.lastTime = performance.now(); 
          animateButton('red');
        }
      }

      // --- RESIZE HANDLER ---
      window.updateButtonPositions = function() {
        const video = document.getElementById('portal-video');
        if (!video) return; 
        
        const containerWidth = video.clientWidth;
        const containerHeight = video.clientHeight;
        if (containerWidth === 0 || containerHeight === 0) return; 

        const containerRatio = containerWidth / containerHeight;
        const videoRatio = 1984 / 1080; 

        let visualWidth, visualHeight, visualTop, visualLeft;

        if (containerRatio > videoRatio) {
          visualWidth = containerWidth; visualHeight = visualWidth / videoRatio;
          visualTop = (containerHeight - visualHeight) / 2; visualLeft = 0;
        } else {
          visualHeight = containerHeight; visualWidth = visualHeight * videoRatio;
          visualTop = 0; visualLeft = (containerWidth - visualWidth) / 2;
        }

        // Helper to set position
        function setPos(elem, relLeft, relTop) {
            const relW = 134 / 1984; 
            const relH = 232 / 1080;
            
            const pxW = relW * visualWidth; 
            const pxH = relH * visualHeight;
            const pxL = visualLeft + ((relLeft / 1984) * visualWidth);
            const pxT = visualTop + ((relTop / 1080) * visualHeight);
            
            elem.style.left = `${pxL}px`; elem.style.top = `${pxT}px`;
            elem.style.width = `${pxW}px`; elem.style.height = `${pxH}px`;
        }

        // Coordinates from original code
        setPos(purpleButton, 464, 749);
        setPos(greenButton, 591, 717);
        setPos(blueButton, 1244, 712);
        setPos(redButton, 1387, 745);
        
        // Re-render current frame to fix scaling
        renderSpriteFrame('purple', animState.purple.current);
        renderSpriteFrame('green', animState.green.current);
        renderSpriteFrame('blue', animState.blue.current);
        renderSpriteFrame('red', animState.red.current);
      }

      portalVideo.addEventListener('loadedmetadata', () => {
        console.log("Portal video metadata loaded.");
        // No image preloading needed for sprite sheets
      });
    });
  </script>
</body>
</html>
